from src.javagen import JavaGenerator
from src.parser import HeimerFormatFileParser
from src.converter import HeimerFormat

from nose.tools import assert_true, assert_false
from subprocess import Popen, PIPE
from os import chdir, getcwd
from os.path import dirname, basename, join
from shutil import rmtree
import difflib

class GeneratorFixture:

    testDir = "test_tmp"
    filename = join(testDir, "Main")

    """
    Initialize a generator fixture by passing it the generator that it is testing,
    functions that can be used to compile and run the generated code for a given
    input file, and a list of tests.
    Parameters:
        generatorType - The CodeGenerator subclass that will be created for each test
        mainFileExtension - The extension of the main file that will be generated
        compileFunc - A function that can be run to compile the generated code
        runFunc - A function that can be run to run the compiled code. It accepts
            one argument, an input file name, and should run the compiled code with
            the input file name as its input and return the
        tests - A list of four-tuples each of which represent a tests. The elements
            in each test are (respectively):
            1) isPass - a boolean representing whether or not this test should pass,
                which allows for tests that are supposed to fail
            2) formatFileName - a string representing the the name of the format file
                that the CodeGenerator will use for this test.
            3) mainFunctionFileName - a string representing the name of the main function
                file. The code in this file will replace the main function code
                generated by the associated CodeGenerator.
            4) inputFileName - a string representing the name of the input file that
                will be passed to runFunc to run the compiled code on.
            5) solutionFileName - a string representing the name of the solution
                file that will be checked against by the output of the compiled code.

    """
    def __init__( self, generatorType, mainFileExtension, tests ):
        self.generatorType = generatorType
        self.mainFileName = GeneratorFixture.filename + "." + mainFileExtension
        self.mainFileDirname = dirname(self.mainFileName)
        self.mainFileBasename = basename(self.mainFileName)
        self.tests = tests

    def runShellCommand( self, command ):
        pipe = Popen( command, stdout=PIPE )
        return pipe.communicate()[0]

    """ A function that can be run to compile the generated code. """
    def compile(self):
        raise NotImplementedError()
    """
    A function that can be run to run the compiled code. It accepts one argument,
    an input file name, and should run the compiled code with the input file name
    as its input and return any output printed to standard out.
    """
    def run( self, inputFileName ):
        raise NotImplementedError()

    def insertMainFunction( self, generator, mainFunctionFileName ):
        def insertedMainFunction(self):
            mainFile = open( mainFunctionFileName, "r" )
            for line in mainFile:
                self.output.writeLine(line)
            self.output.writeNewLine()
            mainFile.close()

        generator.generateMainFunction = insertedMainFunction

    def createGenerator( self, formatFileName ):
        parser = HeimerFormatFileParser(formatFileName)
        formatObject = HeimerFormat(parser.objectModel)
        return self.generatorType( self.mainFileName, formatObject )

    def generateTests(self):
        def test(shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName):
            failed = False
            generator = self.createGenerator(formatFileName)
            self.insertMainFunction( generator, mainFunctionFileName )
            generator.codeGen()
            self.compile()
            output = self.run(inputFile).splitlines()
            solutionFile = open( solutionFileName, "r" )
            solution = solutionFile.readlines()
            for s in difflib.ndiff( output, solution ):
                if s[0] == "+" or s[0] == "-":
                    failed = True
            solutionFile.close()
            shutil.rmtree(GeneratorFixture.testDir)
            if shouldPass:
                return not failed
            else:
                return failed

        for shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName in self.tests:
            yield test(shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName)

class JavaFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, JavaGenerator, "java", tests)

    def compile(self):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        runCommand([ "javac", self.mainFileBasename ])
        chdir(prevWD)

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        output = runCommand([ "java", self.mainFileBasename[:-5], inputFileName ])
        chdir(prevWD)
        return output

def getTest( shouldPass, testName, extension ):
    testDir = join( "tests" )
    if shouldPass:
        testDir = join( testDir, "pass" )
    else:
        testDir = join( testDir, "fail" )
    return (
        shouldPass,
        join( testDir, testName + ".format" ),
        join( testDir, testName + "." + extension ),
        join( testDir, testName + ".input" ),
        join( testDir, testName + ".sln" )
        )
