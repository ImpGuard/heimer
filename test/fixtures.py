from src.javagen import JavaGenerator
from src.pygen import PythonGenerator
from src.parser import HeimerFormatFileParser
from src.converter import HeimerFormat
from helper import *

from os import chdir, getcwd, mkdir
from os.path import dirname, basename, join, isdir
from shutil import rmtree
import difflib
import types

class GeneratorFixture:

    testDir = "test_tmp"
    filename = join(testDir, "Main")

    def __init__( self, generatorType, mainFileExtension, tests ):
        """ Create a GeneratorFixture.

        Arguments:
        generatorType - The CodeGenerator subclass that will be created for each
            test
        mainFileExtension - The extension of the main file that will be
            generated
        tests - A list of tests. Each test is a four-tuple which represents a
            test. The elements of each test are (respectively):
            1) expectedOutcome - a number indicating the expected outcome for
                this test. The meaning behind different expected outcomes are:
                0 - Expecting this test to produce output identical to the
                    solution file
                1 - Expecting this test to produce output different than the
                    solution file
                2 - Expecting this test to fail when parsing the format file
                3 - Expecting this test to fail when compiling the generated
                    code
                4 - Expecting this test to fail when running the compiled
                    generated code
            2) formatFileName - the name of the format file used for this test
            3) mainFunctionFileName - the code in this file will replace the
                main function code generated by the associated CodeGenerator.
            4) solutionFileName - the solution file that will be checked against
                the output of the compiled code.
        """
        self.generatorType = generatorType
        self.mainFileName = GeneratorFixture.filename + "." + mainFileExtension
        self.mainFileDirname = dirname(self.mainFileName)
        self.mainFileBasename = basename(self.mainFileName)
        self.tests = tests

    def compile(self):
        """ Compile the generated code. """
        raise NotImplementedError()

    def run( self, inputFileName ):
        """ Run the generated code. """
        raise NotImplementedError()

    def insertMainFunction( self, generator, mainFunctionFileName ):
        """ Helper to insert the main function into the main file. """
        def insertedMainFunction(self):
            mainFile = open( mainFunctionFileName, "r" )
            for line in mainFile:
                self.output.writeLine(line)
            self.output.writeNewline()
            mainFile.close()

        generator.generateMainFunction = types.MethodType(insertedMainFunction, generator, self.generatorType)

    def createGenerator( self, formatFileName ):
        """ Helper to create a generator given a format file.

        Either returns the associated generator or raises a ValueError.
        """
        parser = HeimerFormatFileParser(formatFileName)
        if parser.parseFailed():
            raise ValueError(parser.failureString())
        formatObject = HeimerFormat(parser.objectModel)
        return self.generatorType( self.mainFileName, formatObject )

    def _createReturnValue( self, testID, expectedOutcome, outcome, msg ):
        """ Helper for generatetestIDs to create return values  """
        if expectedOutcome == outcome:
            return ( 0, testID, None )
        elif expectedOutcome == -outcome:
            return ( -expectedOutcome, testID, None )
        elif outcome >= 0:
            return ( outcome, testID, msg )
        else:
            return None

    def generateTests(self):
        """ Generate test functions for all the tests passed to this fixture.

        Each test will run with the provided format file, input file, solution
        file, and main function file and return a tuple indicating success or
        failure. Each tuple contains an opcode indicating the type of result,
        the test tuple with the various filenames as an identifier, and
        additional information if necessary.

        The different return types are:
            (-4, TestID, None) - Test was expected to fail when running the
                generated code, but it passed
            (-3, TestID, None) - Test was expected to fail when compiling
                generated code, but it passed
            (-2, TestID, None) - Test was expected to fail when parsing the
                format file, but it passed
            (-1, TestID, None) - Test was expected to fail because the output
                did not match the solution file, but it passed
            (0, TestID, None) - Test succeeded
            (1, TestID, Diff) - Test failed because the output did not match the
                solution file
            (2, TestID, ErrorMsg) - Error parsing the format file, ErrorMsg is
                the associated parsing error message
            (3, TestID, ErrorMsg) - Error compiling generated code, ErrorMsg is
                the compilation error message
            (4, TestID, ErrorMsg) - Error running generated code, ErrorMsg is
                the runtime error message

        Note that a return value of test success - (0, Test) - does not indicate
        that the output was produced identical to that of the solution file. A
        test has succeeded if the result matches the expected outcome identified
        in the original test tuple.
        """
        def test( expectedOutcome, formatFileName, mainFunctionFileName, inputFileName, solutionFileName ):
            testID = ( expectedOutcome, formatFileName, mainFunctionFileName, inputFileName, solutionFileName )
            retVal = None
            # Create generator and insert main function
            generator = None
            try:
                generator = self.createGenerator(formatFileName)
            except ValueError as e:
                return self._createReturnValue(testID, expectedOutcome, 2, e.message)
            retVal = self._createReturnValue(testID, expectedOutcome, -2, None)
            if retVal:
                return retVal
            self.insertMainFunction( generator, mainFunctionFileName )
            # Generate code
            generator.codeGen()
            # Compile generated code
            out, err, success = self.compile()
            if not success:
                return self._createReturnValue(testID, expectedOutcome, 3, err)
            retVal = self._createReturnValue(testID, expectedOutcome, -3, None)
            if retVal:
                return retVal
            # Run generated code
            out, err, success = self.run(inputFileName)
            if not success:
                return self._createReturnValue(testID, expectedOutcome, 4, err)
            retVal = self._createReturnValue(testID, expectedOutcome, -4, None)
            if retVal:
                return retVal
            out = out.splitlines()
            # Check output to solution
            diff = ""
            outcome = 1
            isDifferent = False
            solutionFile = open( solutionFileName, "r" )
            solution = "".join(solutionFile.readlines()).splitlines()
            for s in difflib.ndiff( out, solution ):
                diff += s + "\n"
                if s[0] == "+" or s[0] == "-":
                    isDifferent = True
            solutionFile.close()
            if not isDifferent:
                outcome = 0
                diff = None
            return self._createReturnValue(testID, expectedOutcome, outcome, diff)

        for shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName in self.tests:
            yield lambda: test(shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName)

class JavaFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, JavaGenerator, "java", tests)

    def compile(self):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "javac", self.mainFileBasename ])
        chdir(prevWD)
        return out, err, rc == 0

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "java", self.mainFileBasename[:-5], join( "..", inputFileName ) ])
        chdir(prevWD)
        return out, err, rc == 0

class PythonFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, PythonGenerator, "py", tests)

    def compile(self):
        return "", "", True

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "python", self.mainFileBasename, join( "..", inputFileName ) ])
        chdir(prevWD)
        return out, err, rc == 0

def getTest( expectedOutcome, formatFileName, mainFunctionFileName = "", inputFileName = "", solutionFileName = "" ):
    """ Get a test in the standard test directory.

    If the expected outcome is 0, the test will be located in the pass
    directory, otherwise, it will be located in the "fail" directory.  See
    GeneratorFixture for a list of different expected outcome values and their
    meanings.
    """
    testDirectory = join( "test", "tests" )
    formatDirectory = join( testDirectory, "format" )
    mainFileDirectory = join( testDirectory, "main" )

    if expectedOutcome == 0:
        testDirectory = join( testDirectory, "pass" )
    else:
        testDirectory = join( testDirectory, "fail" )
    return (
        expectedOutcome,
        join(formatDirectory, formatFileName),
        join(mainFileDirectory, mainFunctionFileName),
        join(testDirectory, inputFileName),
        join(testDirectory, solutionFileName)
        )

def getTestByName( expectedOutcome, testName, extension ):
    """ Get a test assuming the standard naming scheme.

    Tests under the standard scheme are located in the standard test directory
    in either the pass or fail directory depending on whether or not the test
    is supposed to pass or not.

    Arguments:
    expectedOutcome -- A value indicating the expected outcome for the test.
    testName -- The name of the test. The resulting filenames will be created
        by joining this name with an appropriate extension:
        <testName>.format = format file
        <testName>.<extension> = main function file
        <testName>.input = input file
        <testName.sln = solution file
    extension -- The name of the extension for the test main function file.
        Ideally this would be the extension for the language the main function
        file is written in.
    """
    return getTest(
        expectedOutcome,
        testName + ".format",
        testName + "." + extension,
        testName + ".input",
        testName + ".sln"
        )

def teardownTest():
    rmtree(GeneratorFixture.testDir)

def setupTest():
    mkdir(GeneratorFixture.testDir)

def _testIDToString(testID):
    return   "\texpected outcome  : %s\n" % testID[0] \
           + "\tformat file       : %s\n" % testID[1] \
           + "\tmain function file: %s\n" % testID[2] \
           + "\tinput file        : %s\n" % testID[3] \
           + "\tsolution file     : %s" % testID[4]

def _testResultString( message, testID, output = "" ):
    resultString = "%s\n" % message + \
                   "for test ID:\n%s" % _testIDToString(testID)
    if output != "":
        resultString += "\n\n" + output

    return resultString

def checkTest(test):
    if isdir(GeneratorFixture.testDir):
        teardownTest()
    setupTest()
    opcode, testID, msg = test()
    if opcode == 1:
        assert False, _testResultString( "Output does not match solution", testID, msg )
    elif opcode == -1:
        assert False, _testResultString( "Output was supposed to not match solution", testID)
    elif opcode == 2:
        assert False, _testResultString( "Format file invalid", testID, msg )
    elif opcode == -2:
        assert False, _testResultString( "Format file was supposed to fail", testID )
    elif opcode == 3:
        assert False, _testResultString( "Generated code could not be compiled", testID, msg )
    elif opcode == -3:
        assert False, _testResultString( "Generated code was supposed to not compile", testID )
    elif opcode == 4:
        assert False, _testResultString( "Generated code did not run successfully", testID, msg )
    elif opcode == -4:
        assert False, _testResultString( "Generated code was supposed to not run", testID )
    teardownTest()
