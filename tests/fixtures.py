from src.javagen import JavaGenerator
from src.pygen import PythonGenerator
from src.cppgen import CPPGenerator
from src.parser import HeimerFormatFileParser
from src.converter import HeimerFormat
from helper import *

from os import chdir, getcwd, mkdir
from os.path import dirname, basename, join, isdir
from shutil import rmtree
import difflib
import types

class GeneratorFixture:

    testDir = "test_tmp"
    filename = join(testDir, "Main")

    def __init__( self, generatorType, mainFileExtension, tests ):
        """ Create a GeneratorFixture.

        Arguments:
        generatorType - The CodeGenerator subclass that will be created for each
            test
        mainFileExtension - The extension of the main file that will be
            generated
        tests - A list of tests. Each test is a four-tuple which represents a
            test. The elements of each test are (respectively):
            1) expectedOutcome - a number indicating the expected outcome for
                this test. The meaning behind different expected outcomes are:
                0 - Expecting this test to produce output identical to the
                    solution file
                1 - Expecting this test to produce output different than the
                    solution file
                2 - Expecting this test to fail when parsing the format file
                3 - Expecting this test to fail when compiling the generated
                    code
                4 - Expecting this test to fail when running the compiled
                    generated code
            2) formatFileName - the name of the format file used for this test
            3) mainFunctionFileName - the code in this file will replace the
                main function code generated by the associated CodeGenerator.
            4) solutionFileName - the solution file that will be checked against
                the output of the compiled code.
        """
        self.generatorType = generatorType
        self.mainFileName = GeneratorFixture.filename + "." + mainFileExtension
        self.mainFileDirname = dirname(self.mainFileName)
        self.mainFileBasename = basename(self.mainFileName)
        self.tests = tests

    def compile(self):
        """ Compile the generated code. """
        raise NotImplementedError()

    def run( self, inputFileName ):
        """ Run the generated code. """
        raise NotImplementedError()

    def insertMainFunction( self, generator, mainFunctionFileName ):
        """ Helper to insert the main function into the main file. """
        def insertedMainFunction(self):
            mainFile = open( mainFunctionFileName, "r" )
            for line in mainFile:
                self.currentFile.writeLine(line.rstrip())
            self.currentFile.writeNewline()
            mainFile.close()

        generator.generateMainFunction = types.MethodType(insertedMainFunction, generator, self.generatorType)

    def createGenerator( self, formatFileName ):
        """ Helper to create a generator given a format file.

        Either returns the associated generator or raises a ValueError.
        """
        parser = HeimerFormatFileParser(formatFileName)
        if parser.parseFailed():
            raise ValueError(parser.failureString())
        formatObject = HeimerFormat(parser.objectModel)
        return self.generatorType( self.mainFileName, formatObject )

    def _createReturnValue( self, testID, expectedOutcome, outcome, msg ):
        """ Helper for generatetestIDs to create return values  """
        if expectedOutcome == outcome:
            return ( 0, testID, None )
        elif expectedOutcome == -outcome:
            return ( -expectedOutcome, testID, None )
        elif outcome >= 0:
            return ( outcome, testID, msg )
        else:
            return None

    def generateTests(self):
        """ Generate test functions for all the tests passed to this fixture.

        Each test will run with the provided format file, input file, solution
        file, and main function file and return a tuple indicating success or
        failure. Each tuple contains an opcode indicating the type of result,
        the test tuple with the various filenames as an identifier, and
        additional information if necessary.

        The different return types are:
            (-4, TestID, None) - Test was expected to fail when running the
                generated code, but it passed
            (-3, TestID, None) - Test was expected to fail when compiling
                generated code, but it passed
            (-2, TestID, None) - Test was expected to fail when parsing the
                format file, but it passed
            (-1, TestID, None) - Test was expected to fail because the output
                did not match the solution file, but it passed
            (0, TestID, None) - Test succeeded
            (1, TestID, Diff) - Test failed because the output did not match the
                solution file
            (2, TestID, ErrorMsg) - Error parsing the format file, ErrorMsg is
                the associated parsing error message
            (3, TestID, ErrorMsg) - Error compiling generated code, ErrorMsg is
                the compilation error message
            (4, TestID, ErrorMsg) - Error running generated code, ErrorMsg is
                the runtime error message

        Note that a return value of test success - (0, Test) - does not indicate
        that the output was produced identical to that of the solution file. A
        test has succeeded if the result matches the expected outcome identified
        in the original test tuple.
        """
        def test( expectedOutcome, formatFileName, mainFunctionFileName, inputFileName, solutionFileName ):
            testID = ( expectedOutcome, formatFileName, mainFunctionFileName, inputFileName, solutionFileName )
            retVal = None
            # Create generator and insert main function
            generator = None
            try:
                generator = self.createGenerator(formatFileName)
            except ValueError as e:
                return self._createReturnValue(testID, expectedOutcome, 2, e.message)
            retVal = self._createReturnValue(testID, expectedOutcome, -2, None)
            if retVal:
                return retVal
            self.insertMainFunction( generator, mainFunctionFileName )
            # Generate code
            generator.codeGen()
            # Compile generated code
            out, err, success = self.compile()
            if not success:
                return self._createReturnValue(testID, expectedOutcome, 3, err)
            retVal = self._createReturnValue(testID, expectedOutcome, -3, None)
            if retVal:
                return retVal
            # Run generated code
            out, err, success = self.run(inputFileName)
            if not success:
                return self._createReturnValue(testID, expectedOutcome, 4, err)
            retVal = self._createReturnValue(testID, expectedOutcome, -4, None)
            if retVal:
                return retVal
            out = out.splitlines()
            # Check output to solution
            diff = ""
            outcome = 1
            isDifferent = False
            solutionFile = open( solutionFileName, "r" )
            solution = "".join(solutionFile.readlines()).splitlines()
            for s in difflib.ndiff( out, solution ):
                diff += s + "\n"
                if s[0] == "+" or s[0] == "-":
                    isDifferent = True
            solutionFile.close()
            if not isDifferent:
                outcome = 0
                diff = None
            return self._createReturnValue(testID, expectedOutcome, outcome, diff)

        for shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName in self.tests:
            yield lambda: test(shouldPass, formatFileName, mainFunctionFileName, inputFileName, solutionFileName)

class JavaFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, JavaGenerator, "java", tests)

    def compile(self):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "javac", self.mainFileBasename ])
        chdir(prevWD)
        return out, err, rc == 0

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "java", self.mainFileBasename[:-5], join( "..", inputFileName ) ])
        chdir(prevWD)
        return out, err, rc == 0

class PythonFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, PythonGenerator, "py", tests)

    def compile(self):
        return "", "", True

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "python", self.mainFileBasename, join( "..", inputFileName ) ])
        chdir(prevWD)
        return out, err, rc == 0

class CPPFixture(GeneratorFixture):

    def __init__( self, tests ):
        GeneratorFixture.__init__( self, CPPGenerator, "cpp", tests)

    def compile(self):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "g++", self.mainFileBasename ])
        chdir(prevWD)
        return out, err, rc == 0

    def run( self, inputFileName ):
        prevWD = getcwd()
        chdir(self.mainFileDirname)
        out, err, rc = runShellCommand([ "./a.out", join( "..", inputFileName ) ])
        chdir(prevWD)
        return out, err, rc == 0

def getTest( expectedOutcome, testName, extension, number, **kwargs ):
    """ Get a test assuming the standard naming scheme.

    The result will be a tuple. The 5 elements of the tuple are:
        expectedOutcome
        formatFileName - <testName> + ".format"
        mainFunctionFileName - <testName> + <extension>
        inputFileName - <testName> + <number> + ".input"
        solutionFileName - <testName> + <number> + ".sln"

    Each test will also be concatenated with a directory. The general directory
    structure is:
        tests/files/[pass|fail|main|format]/<fileName>

    Format files will by default be looked for in the "format" directory and main
    files will by default be looked for in the "main" directory. If the expected
    outcome is 0, the input files and the solution files will be located in the
    "pass" directory, otherwise, it will be located in the "fail" directory.
    See GeneratorFixture for a list of different expected outcome values and
    their meanings.

    In order to adjust these directories, pass in the following key arguments:
        globalDir - change the globalDirectory [default: tests/files]
        formatDir - change where to look for format files [default: format]
        mainDir - change where to look for main function files [default: main]
        passDir - change where to look for input/solution files that have an
            expected outcome of 0 [default: pass]
        failDir - change where to look for input/solution files that have an
            expected outcome of not 0 [default: fail]
        inputDir - change where to look for input files within the pass/fail
            directory [default: ""]
        solutionDir - change where to look for solution files within the pass/fail
            directory [default: ""]
    """
    globalDir = kwargs.get( "globalDir", join( "tests", "files" ) )
    formatDir = kwargs.get( "formatDir", "format" )
    mainDir = kwargs.get( "mainDir", "main" )
    passDir = kwargs.get( "passDir", "pass" )
    failDir = kwargs.get( "failDir", "fail" )
    inputDir = kwargs.get( "inputDir", "" )
    solutionDir = kwargs.get( "solutionDir", "" )
    passOrFailDir = passDir if expectedOutcome == 0 else failDir

    if extension.find(".") == -1:
        extension = "." + extension

    return (
        expectedOutcome,
        join(globalDir, formatDir, testName + ".format"),
        join(globalDir, mainDir, testName + extension),
        join(globalDir, passOrFailDir, inputDir, testName + str(number) + ".input"),
        join(globalDir, passOrFailDir, solutionDir, testName + str(number) + ".sln")
        )

def teardownTest():
    rmtree(GeneratorFixture.testDir)

def setupTest():
    mkdir(GeneratorFixture.testDir)

def _testIDToString(testID):
    return   "\texpected outcome  : %s\n" % testID[0] \
           + "\tformat file       : %s\n" % testID[1] \
           + "\tmain function file: %s\n" % testID[2] \
           + "\tinput file        : %s\n" % testID[3] \
           + "\tsolution file     : %s" % testID[4]

def _testResultString( message, testID, output = "" ):
    resultString = "%s\n" % message + \
                   "for test ID:\n%s" % _testIDToString(testID)
    if output != "":
        resultString += "\n\n" + output

    return resultString

def checkTest(test):
    if isdir(GeneratorFixture.testDir):
        teardownTest()
    setupTest()
    opcode, testID, msg = test()
    if opcode == 1:
        assert False, _testResultString( "Output does not match solution", testID, msg )
    elif opcode == -1:
        assert False, _testResultString( "Output was supposed to not match solution", testID)
    elif opcode == 2:
        assert False, _testResultString( "Format file invalid", testID, msg )
    elif opcode == -2:
        assert False, _testResultString( "Format file was supposed to fail", testID )
    elif opcode == 3:
        assert False, _testResultString( "Generated code could not be compiled", testID, msg )
    elif opcode == -3:
        assert False, _testResultString( "Generated code was supposed to not compile", testID )
    elif opcode == 4:
        assert False, _testResultString( "Generated code did not run successfully", testID, msg )
    elif opcode == -4:
        assert False, _testResultString( "Generated code was supposed to not run", testID )
    teardownTest()
